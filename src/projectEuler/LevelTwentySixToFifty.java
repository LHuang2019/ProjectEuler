package projectEuler;

import java.math.BigInteger;
import java.util.ArrayList;

/**
 * The class which contain methods that solve problem 25 to 50, except few
 * @author Li Huang
 * @version 12.21.2015
 */
public class LevelTwentySixToFifty extends ProjectHelper{

    /**
     * Method which solves problem 48 using BigInteger and loops
     * @param maxNum the maximum number and its exponent
     * @param digit the amount digit of the sum that wants to output
     * @return the last giving input digit of the sum
     */
    public static String selfPowers(int maxNum, long digit)
    {
        BigInteger current = new BigInteger("0");
        BigInteger mod = BigInteger.valueOf(digit);
        BigInteger sum = new BigInteger("0");

        for (int i = 1; i < maxNum; i++)
        {
            current = BigInteger.valueOf(i);
            sum = sum.add(current.modPow(current, mod));
            sum = new BigInteger(sum.mod(mod).toString());
        }

        String output = sum.toString();

        return output;
    }

    /**
     * Method which solves problem 28 using loops
     * @param n the n spiral
     * @return the sum of numbers on the diagonals in a n by n spiral
     */
    public static int numberSpiralDiagonals (int n)
    {   
        int sum = 1;
        int current = 3;
        for (int i = 1; i <= (n - 1) / 2; i++)
        {
            sum += 4 * (current * current) - 12 * i;
            current += 2;
        }

        return sum;
    }

    /**
     * Method which solves problem 29 using brute force
     *      will be updated
     * @param max a and b
     * @return the distinct terms in the sequence generated by a and b
     */
    public static int distinctPowers(int max)
    {
        boolean condition = true;
        BigInteger current = new BigInteger("0");
        ArrayList<BigInteger> list = new ArrayList<BigInteger>();
        for (int a = 2; a <= max; a++)
        {
            for (int b = 2; b <= max; b++)
            {
                current = new BigInteger(Integer.toString(a));
                current = current.pow(b);

                for (int i = 2; i < list.size(); i++)
                {
                    if (current.equals(list.get(i)))
                    {
                        i = list.size();
                        condition = false;
                    }
                }
                if (condition)
                {
                    list.add(0, current);
                }
                condition = true;
            }
        }
        return list.size();
    }

    /**
     * Method which solves problem 30 using loops
     * @param pow the power 
     * @return sum of all numbers that can be written 
     *         as the sum given powers of their digits
     */
    public static int digitFifthPowers (double pow)
    {
        long max = (long) (pow * Math.pow(9, pow));
        int strLength = Long.toString(max).length();
        max = (long) (strLength * Math.pow(9, pow));

        int sum = 0;

        for (int i = 2; i <= max; i++)
        {
            int sumOfPowers = 0;
            int current = i;

            while (current > 0) {
                int currentDigit = current % 10;

                currentDigit = (int) Math.pow(currentDigit, pow);
                sumOfPowers += currentDigit;
                current /= 10;
            }

            if (sumOfPowers == i) {
                sum += i;
            }
        }

        return sum;
    }
    
    /**
     * Method which solves problem 34 using similar approach as problem 30 
     * @return sum of all numbers all numbers 
     *          which are equal to the sum of the factorial of their digits
     */
    public static int digitFactorials ()
    {
        long max = 7 * factorialCalculator(9); //the upper bound
        int currentFactorial = 0;
        int sum = 0;
        
        for (int i = 3; i <= max; i++)
        {
            int current = i;
            int numSum = 0;
            
            while (current > 0) {
                int currentDigit = current % 10;

                currentFactorial = (int)factorialCalculator(currentDigit);
                numSum += currentFactorial;
                current /= 10;
            }

            if (numSum == i) {
                sum += i;
            }
        }

        return sum;
    }
    
    /**
     * Method which solves problem 36 using brute force
     * @param max the max number
     * @return the sum of all number that is palindrome in base 2 and 10
     */
    public static int doubleBasePalindromes(int max)
    {
        String binary = "";
        int sum = 0;
        
        for (int i = 1; i <= max; i += 2)
        {
            if (palindromeIntChecker(i))
            {
                 binary = Integer.toBinaryString(i);
                 if (palindromeStringChecker(binary))
                 {
                     sum += i;
                 }
            }
        }
        
        return sum;
    }
}